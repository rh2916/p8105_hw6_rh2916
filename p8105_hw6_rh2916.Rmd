---
title: "p8105_hw6_rh2916"
author: "Rui Huang"
date: "November 16, 2018"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(janitor)
library(purrr)
library(modelr)
library(mgcv)
```

### Problem 1 

```{r}
df_homicide = read.csv("./data/homicide-data.csv") %>% 
  janitor::clean_names() %>% 
  mutate(city_state = paste(city, state, sep = ","),
         sloving_status = ifelse(disposition == "Closed by arrest", 1, 0)) %>%
  filter(city_state != "Dallas, TX" & city_state != "Phoenix, AZ" & city_state != "Kansas City, MO" & city_state != "Tulsa, AL") %>%
  mutate(victim_race = ifelse(victim_race == "White", "white","non_white"),
         victim_race = fct_relevel(victim_race,"white", "non_white"),
         victim_age = as.numeric(victim_age))
```

For the city of Baltimore, MD, use the glm function to fit a logistic regression with resolved vs unresolved as the outcome and victim age, sex and race (as just defined) as predictors. Save the output of glm as an R object; apply the broom::tidy to this object; and obtain the estimate and confidence interval of the adjusted odds ratio for solving homicides comparing non-white victims to white victims keeping all other variables fixed.

```{r}
Baltimore_homicide =
  df_homicide %>% 
  filter(city_state == "Baltimore,MD") 
  
glm_sloving_status = glm(sloving_status ~ victim_age + victim_sex + victim_race, data = Baltimore_homicide, family = binomial())

save(glm_sloving_status,file = "./homicide_balti.rdata")

glm_sloving_status %>% 
  broom::tidy() %>% 
  mutate(OR = exp(estimate),
         log_OR = estimate,
         OR_lower = exp(estimate - std.error * 1.96),
         OR_upper = exp(estimate + std.error * 1.96)) %>%
  select(term, log_OR, OR, OR_lower, OR_upper, p.value) %>% 
  knitr::kable(digits = 3)


```

Now run glm for each of the cities in your dataset, and extract the adjusted odds ratio (and CI) for solving homicides comparing non-white victims to white victims. Do this within a “tidy” pipeline, making use of purrr::map, list columns, and unnest as necessary to create a dataframe with estimated ORs and CIs for each city.

```{r}
func_solving = function(city){
  
city_homicide = df_homicide %>%
  filter(city_state == city) 
  
glm_sloving_status = glm(sloving_status ~  victim_age + victim_sex + victim_race, data = city_homicide, family = binomial())


glm_city = glm_sloving_status %>% 
  broom::tidy() %>% 
  mutate(OR = exp(estimate),
         OR_lower = exp(estimate - std.error * 1.96),
         OR_upper = exp(estimate + std.error * 1.96)) %>%
  select(term, OR, OR_lower, OR_upper, p.value) %>% 
  knitr::kable(digits = 3)
}

df_homicide %>% 
  group_by(city_state) %>% 
  nest() %>% 
  map_df(., func_solving) %>% 
  unnest %>%
  knitr::kable(digit = 3)

```


```{r}
purrr::map_df(unique(df_homicide$city_state), func_solving)
```

Create a plot that shows the estimated ORs and CIs for each city. Organize cities according to estimated OR, and comment on the plot.

```{r}
ggplot(glm_city, aes(x=reorder(city_state, -OR),y=OR))+
  geom_point() +
  geom_errorbar(aes(ymin = OR_lower, ymax = OR_upper)) +
  geom_hline(yintercept = 1, alpha = 0.4) +
  theme(legend.position = "bottom", axis.text.x = element_text(angle = 90, hjust = 1), legend.key.width = unit(0.15,'cm')) +
  labs(
    title = "Adjusted OR for homicide resolvation among non-whites and whites by city",
    x = "City, State",
    y = "Adjusted Odds Ratio with 95% CIs"
  )
  ggtitle('Adjusted Odds Ratio with 95% CIs for each city')
```


### Problem 2

Load and clean the data for regression analysis 

```{r, message=F}
df_birthweight_raw = read.csv("./data/birthweight.csv")

df_birthweight = 
  df_birthweight_raw %>% 
  janitor::clean_names() %>% 
  mutate(babysex = as.factor(babysex),
         frace = as.factor(frace),
         mrace = as.factor(mrace),
         malform = as.factor(malform))

skimr::skim(df_birthweight)
```

Propose a regression model for birthweight.
Use backward

```{r}
full_model = lm(bwt ~ ., data = df_birthweight)
summary(full_model)

step_model = step(full_model, direction = "both", trace = FALSE)
summary(step_model)
```


```{r}
lm_model = lm(bwt ~ bhead + babysex + blength + delwt + gaweeks + wtgain + smoken, data = df_birthweight)

df_birthweight %>% 
  modelr::add_predictions(lm_model) %>% 
  modelr::add_residuals(lm_model) %>% 
  ggplot(aes(x=pred,y=resid))+
  geom_point(aes(alpha=.2))+
  labs(
    title = "Residuals vs fitted values of birthweight",
    x = "Predictions", y = "Residuals"
  )
```

Compare your model to two others:

One using length at birth and gestational age as predictors (main effects only)
One using head circumference, length, sex, and all interactions (including the three-way interaction) between these


```{r}
main_effect_model = lm(bwt ~ blength + gaweeks, data = df_birthweight)
interaction_model = lm(bwt ~ bhead + blength + babysex + bhead * blength * babysex, data = df_birthweight)
```

```{r}
cv_df = 
  crossv_mc(df_birthweight, 100)

cv_df = cv_df %>% 
  mutate(train = map(train, as_tibble),
         test = map(test, as_tibble)) %>% 
  mutate(lm_mod = map(train,~lm(bwt ~ bhead + babysex + blength + delwt + gaweeks + wtgain + smoken, data=.x)),
         main_effect_mod = map(train, ~lm(bwt~blength+gaweeks,data=.x)),
         interaction_mod = map(train, ~lm(bwt~bhead + blength + babysex + bhead * blength * babysex, data=.x))) %>% 
  mutate(rmse_lm_mod = map2_dbl(lm_mod,test, ~rmse(model = .x, data=.y)),
         rmse_main_effect_mod = map2_dbl(main_effect_mod,test, ~rmse(model = .x, data=.y)),
         rmse_interaction_mod = map2_dbl(interaction_mod,test, ~rmse(model = .x, data=.y))) 
```

```{r}
cv_df %>% 
  select(starts_with("rmse")) %>% 
  gather(key = model, value = rmse) %>% 
  mutate(model = str_replace(model, "rmse_", ""),
         model = fct_inorder(model)) %>% 
  ggplot(aes(x = model, y = rmse)) + geom_violin()
```



